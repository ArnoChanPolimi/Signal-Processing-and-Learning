##### Chen Hong   11024836@polimi.it

###### 4th Dec 2024

###### Course: SIGNAL PROCESSING AND LEARNING



# Adaptive Interference Mitigation on Audio Signals





## Project Overview:

The title describes a stereo(two-channel) audio signal $s(t)=[s_{1}, s_{2}]^T$. This signal is contaminated by noise $w(t)$, which is not directly independent but instead results from an external noise source $n(t)$. The noise $w(t)$ is generated by applying a 2 x 2 filter $h(t)$ to $n(t)$ through convolution. The mathematical model for the sampled version of the signal is:
$$
s_{in}[u]=s[u]+w[u]
$$

$$
s_{in}[u]= \boldsymbol{[} \; s_1[u]\quad s_2[u]\; \boldsymbol{]} +\mathbf{[}\;w_1[u]\quad w_2[u]\;\boldsymbol{]}
$$

​	where
$$
{w}[u]=\mathbf{h}*{n}[u]
$$
The provided data files represent the noise-interfered signals, denoted as **Sin_x**, where x = a, b, c, indicating increasing levels of noise difficulty. Additionally, a reference file, **Sn_ref_x**, is provided, where the interference signal $s_{ref}$ is a noise-related reference signal measured from the environment ($e.g.$ an external noise signal measured through another microphone) indicating the source of the interference. It is generated by $n[u]$ through the unknown transfer function $G(z)$:
$$
{s}_{ref}[u]=\mathbf{g}*{n}[u]
$$
The goal of the numerical exercise is to process stereo audio signals that are contaminated with noise and to extract the clean or noise-mitigated signals. The performance of the noise mitigation is evaluated by listening to the processed signals through a stereo headset using the $Matlab$ command `sound(S_est, fs)`, where `S_est` is the estimated clean stereo signal and `fs` is the sampling frequency.

### Filter Design:



In order to generate an estimate $w[u]$ of the noise $\hat{w}[u]$, we design an adaptive filter $A(z|\mathbf{a})$ ($FIR$ filter), the weight coefficients of which are represented by a vector $\mathbf{a}$, and the output is:
$$
\hat{w}[u]=A(z|\mathbf{a})*s_{ref}[u]
$$
Based on $S_{in}$ and the reference noise signal $S_{ref}$ , and implemented using an adaptive filtering technique ($LMS$) to optimize the weighting coefficients of the filter $A(z|\mathbf{a})$ that is capable of maximizing noise suppression.

The final output error signal is:
$$
\epsilon[u|\mathbf{a}]=s_{est}[u] = s_{in}[u]-\hat{w}[u]
$$


### Signal Reconstruction:

Applying the designed filter $A(z|\mathbf{a})$, the noise $w$ affecting the original signal $s[u]$ is estimated, and the estimated signal $s_{est}[u]$ is obtained by subtracting the estimated noise $w[u]$ from the signal $s_{in}[u]$.
$$
\mathbf{s}_{\mathrm{est}}[u]=\mathbf{s}_{\mathrm{in}}[u]-\mathbf{A}*\mathbf{s}_{\mathrm{ref}}[u]
$$

## 

<img src="D:\Aa_Polimi\Polimi_Studying\Sem1\SP&L\homework\HW2\plots_Hw2\diagram.png" alt="diagram" style="zoom:22%;" />



### Optimization Method($LMS$)

Adjust the filter parameter $\mathbf{a}$ to minimize the noise in the error signal $\epsilon[u|\mathbf{a}]$ while preserving the target signal $s[u]$ as much as possible. The $LMS$ method achieves this by recursively updating the filter weights to gradually approximate the minimum mean square error ($MSE$).

Definition of cost function(Mean Square Error ($MSE$)):
$$
\begin{split}
J(\mathbf{a})&=\mathbb{E}[(\epsilon[u|\mathbf{a}])^2] \\
&= \mathbb{E}[(s_{in}[u]-\hat{w}[u])^2] \\
&= \mathbb{E}[(s_{in}[u]-s_{ref}[u]\cdot \mathbf{a})^2] \\
&= \mathbb{E}[s^2_{in}[u]-2\cdot s_{in}[u]\cdot s_{ref}[u]\cdot \mathbf{a} + s^2_{ref}[u]\cdot \mathbf{a}^T\mathbf{a}] \\
\end{split}
$$
The gradient descent method is used to update the filter coefficients as follows:
$$
\begin{split}
\frac{\partial J}{\partial\mathbf{a}}&=-2\cdot \mathbb{E}[ s_{in}\cdot s_{ref} - s^2_{ref}\cdot \mathbf{a}] \\
&= -2\cdot \mathbb{E}[s_{ref}(s_{in} - s_{ref}\cdot \mathbf{a}) ] \\
&= -2\cdot \mathbb{E}[\epsilon\cdot s_\mathrm{ref}]
\end{split}
$$
In the $LMS$ algorithm, the expectation is not computed directly, but is approximated using the current observed values.
$$
\frac{\partial J}{\partial\mathbf{a}} \approx -2\cdot \epsilon[k]\cdot s_{ref}[k]
$$
The weight update formula for the filter $\mathbf{A}$ is as follows:
$$
\begin{split}
\mathbf{a}[n+1]&= \mathbf{a}[n] - \frac{\mu_0}{1+\alpha \cdot(\epsilon[k])^2} \cdot \frac{\partial J}{\partial\mathbf{a}} \\
&= \mathbf{a}[n]+\frac{2\mu_0}{1+\alpha \cdot(\epsilon[k])^2}\cdot \epsilon[k]\cdot s_{ref}[k]
\end{split}
$$



## 卡尔曼滤波方法

**初始化阶段：**

- 滤波器阶数 p=80：表示滤波器能够捕捉的噪声时间关联的范围。
- 权重初始化 a=0：假设初始状态下滤波器没有任何噪声估计能力。
- 协方差矩阵 P：权重估计的不确定性，初值为一个小值（信任权重初始值接近真实值）。
- 过程噪声协方差 Q：描述权重更新中的系统误差，设为一个小值，允许适配器缓慢变化。
- 观测噪声协方差 R：描述观测值中的噪声大小，设为较大的值以应对测量噪声。

- - 

- **循环处理每个时间点：**

  - 对信号每一时刻 $n$ 和每个通道 $col$分别进行处理。

  - 参考信号窗口 

    $sref,window$

    ：从参考噪声 

    $Sref,a$

     中截取长度为$p$的信号段，用于估计当前噪声。

    - $s_{\mathrm{ref,window}}=[s_{\mathrm{ref,a}}(n-p+1),...,s_{\mathrm{ref,a}}(n)]$ 若$n≥p$，否则用零补齐。



**状态空间模型定义**

- **状态向量：** 将滤波器权重 $\mathbf{a}$ 视为随时间变化的状态：

$$
\mathbf{a}[n]=[a_1[n],a_2[n],\ldots,a_p[n]]^T
$$

**状态转移模型：** 假设滤波器权重在时间上的变化是平滑的，可以用随机游走模型描述：
$$
\mathbf{a}[n]=\mathbf{a}[n-1]+\mathbf{q}[n]
$$
其中 $\mathbf{q}[n]\sim\mathcal{N}(0,Q)$是过程噪声，控制权重变化的随机性。

**观测模型：** 通过参考信号 $Sref[n] $估计噪声 $w[n]$：
$$
w[n]=\mathbf{a}[n]^T\mathbf{s}_\mathrm{ref}[n]
$$
其中$s_{ref}[n]$是参考信号窗口。



**预测阶段：**

- 权重预测：

  $\mathbf{a}_\mathrm{pred}=\mathbf{a}$

  - 假设当前的权重不变作为预测值。

- 协方差预测：

  $\mathbf{P}_\mathrm{pred} = \mathbf{P} + \mathbf{Q}$

  - 预测滤波器的不确定性随着时间增加。

**更新阶段：**

- **计算卡尔曼增益：**

$$
K=\frac{\mathbf{P}_{\mathrm{pred}}\mathbf{s}_{\mathrm{ref,window}}}{\mathbf{s}_{\mathrm{ref,window}}^T \mathbf{P}_{\mathrm{pred}}\mathbf{s}_{\mathrm{ref,window}}+\mathbf{R}}
$$



权重更新：
$$
a=a_{\mathrm{pred}}+K\cdot\left(\mathrm{Sin}_a(n)-s_{\mathrm{ref,window}}^\top a_{\mathrm{pred}}\right)
$$
协方差更新：
$$
P=\begin{pmatrix}I-Ks_{\text{ref,window}}^{\top}\end{pmatrix}P_{\mathrm{pred}}
$$






**噪声估计与信号去噪：**

- 估计噪声：



## d&e

#### **Signal Segmentation:**

- First, the entire signal is divided into several smaller segments, each with a fixed length.
- These segments have a certain **overlap**, typically half the length of the segment. The overlapping portion helps to mitigate edge effects in signal processing, ensuring smoother transitions between segments.

#### **Window Function Application:**

- Each segment of the signal is windowed using a window function (such as a Hamming window or rectangular window). This reduces spectral leakage caused by the windowing effect. The purpose of windowing is to ensure that the signal transitions smoothly at the segment boundaries, rather than being abruptly truncated.

- $$
  x_\mathrm{windowed}{[n]}=x[n]\cdot w[n]
  $$

#### **Frequency Spectrum Calculation (FFT):**

- For each segment that has been windowed, its **frequency spectrum** is computed using the Fast Fourier Transform (FFT) to convert the signal to the frequency domain.
- After calculating the spectrum, we obtain the **amplitude** and **phase** information of the signal at various frequencies. For denoising purposes, the amplitude spectrum (power spectrum) is primarily considered, as noise typically manifests as low-amplitude frequency components in the spectrum.

$$
X[k]=\sum_{n=0}^{N-1}x[n]e^{-j2\pi\frac{kn}{N}}
$$

#### **Denoising Process:**

- By analyzing the amplitude spectrum of each segment, we can identify frequency components with particularly low amplitudes, which are generally considered noise.
- By setting a **threshold**, frequency components with amplitudes below the threshold can be removed, effectively removing the noise.
- After noise removal, the remaining signal exhibits a clearer frequency spectrum, corresponding to the denoising process.

$$
X[k]=
\begin{cases}
0 & \mathrm{if~}|X[k]|<T \\
X[k] & \mathrm{otherwise} & & 
\end{cases}
$$



#### **Time-Frequency Representation (Plotting the Spectrogram):**

- After denoising each segment, you will obtain the frequency spectrum (i.e., the power spectrum) for each segment. These spectra can be arranged as rows in a matrix, resulting in a time-frequency map.
- This time-frequency map can be visualized using tools like `imagesc` (or other visualization methods), which shows the variation of the signal’s spectrum over time. Such a plot aids in visualizing the changes in the signal across both time and frequency domains.

#### **Reconstructing the Denoised Signal:**

- Finally, by removing noise from the frequency spectrum of each segment, the denoised signal can be reconstructed.

$$
x[n]=\frac{1}{N}\sum_{k=0}^{N-1}X[k]e^{j2\pi\frac{kn}{N}}
$$













## Matlab Experimental Process

Due to the length of the sequence, we select a segment to observe the comparison between the denoised estimated signal $s_{est}$ and the original noisy signal $s_{in}$.

![Signal_Comparison_Plot](D:\Aa_Polimi\Polimi_Studying\Sem1\SP&L\homework\HW2\Signal_Comparison_Plot.jpg)

```%% %%%%%% ----- SP&L Homework2 -------- %%%%%%%%%%%%%%%
load("Hw2a.mat");

% % sound(Sin_a);

% sound(Sn_ref_a);

%% 

% 输入信号Sin和噪声信号Sref的大小

[N, M] = size(Sin_a);         % M=2 (双声道)

% 滤波器初始化

mu = 0.0001;                  % 步长因子

Steps_Num_Adapter = 2000;     % 适配器阶数

Adapter = zeros(Steps_Num_Adapter, M);      % 初始化滤波器参数

e = zeros(M);            % 误差信号

% LMS算法

for n = 1:N  % 从第1个点到第N个点

​    w_hat = zeros(M);        % 滤波器输出

​    for col = 1 : M

​        for i = 1 : Steps_Num_Adapter

​            if n+1-i > 0

​                w_hat(col) = w_hat(col) + Adapter(i, col) * Sn_ref_a(n+1-i, col); % 求出估计噪声

​            end

​        end

​    end

​    % 误差信号

​    for col=1 : M

​        e(col) = Sin_a(n, col) - w_hat(col);  % 被噪声污染的信号减去估计的噪声

​    end

​    % 更新滤波器参数（适配器）

​    if n > 1

​        for col = 1 : M

​            for i = 1 : Steps_Num_Adapter % i表示为Adapter 的第i个权重系数

​                if n-i > 0

​                    Adapter(i, col) = Adapter(i, col) + mu * 2 * e(col) * Sn_ref_a(n-i, col);  % 更新规则

​                end

​            end

​        end

​    end

end

w_hat_squence = zeros(N+Steps_Num_Adapter-1, M); % 噪声序列

Sin_est = zeros(N, M); % 进行去除噪声后的信号序列

for col = 1 : M

​    w_hat_squence(:, col) = conv(Sn_ref_a(:, col), Adapter(:, col));

​    Sin_est(:, col) = Sin_a(:, col) - w_hat_squence(1:N, col);
end

figure(1);

% 绘制 Sin_Adapter 数据，指定颜色为红色

plot(Sin_est(:,2), 'Color', 'r');  % 红色线条

hold on;

% 绘制 Sin_a 数据，指定颜色为蓝色

plot(Sin_a(:,2), 'Color', 'b');  % 蓝色线条

hold off;

% 添加图例

legend('Sin_est', 'Sin_a');

% 添加标题

title('Signal Comparison Plot');

xlabel('time');

ylabel('Signal Amplitude');

xlim([610000, 611000]);  % 横轴范围
```

